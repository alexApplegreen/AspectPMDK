#ifndef TRANSACTION_ADVICE_CPP_AH
#define TRANSACTION_ADVICE_CPP_AH

#include <libpmemobj++/pool.hpp>
#include <libpmemobj++/transaction.hpp>
#include <libpmemobj++/detail/common.hpp>
#include <libpmemobj++/utils.hpp>
#include "attribute_cpp.ah"
#include "../util/log.h"
#include "transactionSlice.ah"
#include <stdexcept>
#include <libpmemobj.h>
#include <type_traits>
#include <map>
#include <functional>

aspect transaction_CPP {

    std::map<const char*, PMEMoid> aggregate_oids;

    pointcut transactionCPP() = AOP_CPP::transactionalCpp() && !"void %::dump()";

    advice transactionCPP() : slice cloned_members;

    // initially log all found members of class and persist members
    // TODO woher den Pool holen?
    advice construction(transactionCPP()) : after() {
        log_info("Instantiated persistent Aggregate. Members:");
        tjp->target()->dump();
    }

    // forbid referencing of members
    advice ref(transactionCPP()) : around() {
        throw new std::runtime_error("Do not reference transactional data");
    }

    advice set(transactionCPP() && !"static % ...::%") : after() {
        JoinPoint::Entity* const member = tjp->entity();

        // add all newly referenced members to map
        if (std::is_pointer<JoinPoint::Entity>::value) {
            if (aggregate_oids.find(JoinPoint::signature()) == aggregate_oids.end()) {
                // save OID of member
                aggregate_oids.insert(std::pair<const char*, PMEMoid>(JoinPoint::signature(), pmemobj_oid(tjp->entity())));
            }
        }

        log_debug("adding member %s to transaction", JoinPoint::signature());
        try {
            pmem::obj::transaction::snapshot<JoinPoint::Entity>(member);
        }
        catch (pmem::transaction_error e) {
            log_warn(e.what());
        }
    }

    advice get(transactionCPP() && !"static % ...::%") : around() {
        // get member from pool by OID and return result
        PMEMoid result;
        TOID_DECLARE(JoinPoint::Entity, std::hash<char*>{}(JoinPoint::signature()));
        TOID_ASSIGN(JoinPoint::Entity, result);

        try {
            result = aggregate_oids.at(JoinPoint::signature());
            *tjp->entity() = (JoinPoint::Entity)D_RW(result);
        }
        catch (std::out_of_range e) {
            tjp->proceed();
        }
    }

    advice execution(transactionCPP()) : around() {
        log_info("Wrapping function with transaction: %s", tjp->signature());

        auto pop = pmem::obj::pool_by_vptr(tjp->that());
        pmem::obj::transaction::run(pop, [&] {
            tjp->proceed();
        });
    }
};

#endif
