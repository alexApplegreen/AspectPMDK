#ifndef TRANSACTION_ADVICE_CPP_AH
#define TRANSACTION_ADVICE_CPP_AH

#include <libpmemobj++/pool.hpp>
#include <libpmemobj++/transaction.hpp>
#include <libpmemobj++/utils.hpp>
#include "attribute_cpp.ah"
#include "../util/log.h"
#include "transactionSlice.ah"

aspect transaction_CPP {

    pointcut transactionCPP() = AOP_CPP::transactionalCpp() && !"void %::dump()";

    advice transactionCPP() : slice cloned_members;

    advice construction(transactionCPP()) : after() {
        log_info("Instantiated persistent Aggregate. Members:");
        tjp->target()->dump();
    }

    advice execution(transactionCPP()) : around() {
        // Behandeln von read Operationen (Return und keine Parameter)
        if (tjp->result() != 0 && JoinPoint::ARGS == 0) {
            log_info("Wrapping function with transaction: %s and re-routing return", tjp->signature());

            *tjp->result() = *tjp->target()->getMember(tjp->entity());
        }

        // Behandeln von Write Operationen (kein Return und Parameter)
        else if (tjp->result() == 0 && JoinPoint::ARGS == 1) {
            log_info("Wrapping function with transaction: %s and re-routing Write Parameter", tjp->signature());

            *tjp->target()->getMember(tjp->entity()) = *tjp->arg<0>();
        }

        auto pop = pmem::obj::pool_by_vptr(tjp->that());
        pmem::obj::transaction::run(pop, [&] {
            tjp->proceed();
        });
    }
};

#endif
