#ifndef TRANSACTION_SLICE_AH
#define TRANSACTION_SLICE_AH

#include "../util/JPTL.h"
#include "../util/log.h"
#include <type_traits>
#include <libpmemobj++/persistent_ptr.hpp>

template<typename MemberInfo, typename CONTEXT>
struct MemberCopy {
  struct EXEC {
    struct RG : public CONTEXT::Copy {
      pmem::obj::persistent_ptr<typename MemberInfo::ReferredType> p_member;

      template <typename THAT>
      static void dump(THAT *obj) {
        log_info("Member: %s", MemberInfo::name());
        CONTEXT::Copy::dump(obj);
      }
    };

    struct ST : public CONTEXT::Copy {
      template <typename THAT>
      static void dump(THAT *obj) {
        log_info("Member: %s", MemberInfo::name());
        CONTEXT::Copy::dump(obj);
      }
    };

    typedef typename std::conditional<static_cast<bool>(MemberInfo::spec & AC::SPEC_STATIC), ST, RG>::type Copy;
  };
};

template<typename MemberInfo>
struct MemberCopy<MemberInfo, void> {
  struct EXEC {
    struct Copy {
      template <typename THAT>
      static void dump(THAT *obj) {}
    };
  };  // initial EXEC
};

slice struct cloned_members {

    typedef JPTL::MemberIterator<JoinPoint, MemberCopy>::EXEC::Copy Copy;

public:
    void dump() {
        Copy::dump((cloned_members*) this);
    }

    template<class T>
    T* getMember(T* member) const {
        return (T*)(member);
    }
};

#endif
