#ifndef TRANSACTION_SLICE_AH
#define TRANSACTION_SLICE_AH

#include "../util/JPTL.h"
#include "../util/log.h"
#include <type_traits>
#include <libpmemobj++/persistent_ptr.hpp>
#include <map>

template<typename MemberInfo, typename CONTEXT>
struct MemberCopy {
  struct EXEC {
    struct RG : public CONTEXT::Copy {
      // Instanz von MemberInfo erzeugen
      // Member sind noch gar nicht persistent, Tests funktionieren trotzdem?
      typename MemberInfo::ReferredType _member;

      // So sollte es doch eigentlich aussehen:
      // pmem::obj::persistent_ptr<typename MemberInfo::ReferredType> p_member;

      template <typename THAT>
      static void dump(THAT *obj) {
        log_info("Member: %s", MemberInfo::name());
        CONTEXT::Copy::dump(obj);
      }
    } __attribute__((packed));

    struct ST : public CONTEXT::Copy {
      template <typename THAT>
      static void dump(THAT *obj) {
        log_info("Member: %s", MemberInfo::name());
        CONTEXT::Copy::dump(obj);
      }
    } __attribute__((packed));

    typedef typename std::conditional<static_cast<bool>(MemberInfo::spec & AC::SPEC_STATIC), ST, RG>::type Copy;
  };
};

template<typename MemberInfo>
struct MemberCopy<MemberInfo, void> {
  struct EXEC {
    struct Copy {
      template <typename THAT>
      static void dump(THAT *obj) {}
    };
  };  // initial EXEC
};

slice struct cloned_members {

    typedef JPTL::MemberIterator<JoinPoint, MemberCopy>::EXEC::Copy Copy;

public:
    void dump() {
        Copy::dump((cloned_members*) this);
    }
};

#endif
