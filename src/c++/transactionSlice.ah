#ifndef TRANSACTION_SLICE_AH
#define TRANSACTION_SLICE_AH

#include "../util/JPTL.h"
#include "../util/log.h"
#include <type_traits>
#include <libpmemobj++/experimental/self_relative_ptr.hpp>
#include <libpmemobj++/detail/common.hpp>
#include <libpmemobj.h>
#include <new>
#include <cstdlib>

template<typename MemberInfo, typename CONTEXT>
struct MemberCopy {
  struct EXEC {
    struct RG : public CONTEXT::Copy {
      // Instanz von MemberInfo erzeugen
      typename MemberInfo::ReferredType _member;

      template <typename THAT>
      static void dump(THAT *obj) {
        log_info("Member: %s", MemberInfo::name());
        CONTEXT::Copy::dump(obj);
      }
    };

    struct ST : public CONTEXT::Copy {
      template <typename THAT>
      static void dump(THAT *obj) {
        log_info("Member: %s", MemberInfo::name());
        CONTEXT::Copy::dump(obj);
      }
    };

    typedef typename std::conditional<static_cast<bool>(MemberInfo::spec & AC::SPEC_STATIC), ST, RG>::type Copy;
  };
};

template<typename MemberInfo>
struct MemberCopy<MemberInfo, void> {
  struct EXEC {
    struct Copy {
      template <typename THAT>
      static void dump(THAT *obj) {}
    };
  };  // initial EXEC
};

slice struct cloned_members {

    typedef JPTL::MemberIterator<JoinPoint, MemberCopy>::EXEC::Copy Copy;

public:
    void dump() {
        Copy::dump((cloned_members*) this);
    }

    void* operator new(std::size_t count) {
        pmem::obj::experimental::self_relative_ptr<JoinPoint::That> pptr;
        pptr = pmemobj_tx_alloc(count, pmem::detail::type_num<JoinPoint::That>());
        void* ptr = pptr.get();
        if (ptr) {
            return ptr;
        }
        else {
            throw new std::bad_alloc{};
        }
    }

    void* operator new(std::size_t count, void* ptr) {
        pmem::obj::experimental::self_relative_ptr<JoinPoint::That> pptr;
        pptr = pmemobj_tx_alloc(count, pmem::detail::type_num<JoinPoint::That>());
        ptr = pptr.get();
        if (ptr) {
            return ptr;
        }
        else {
            throw new std::bad_alloc{};
        }
    }
};

#endif
